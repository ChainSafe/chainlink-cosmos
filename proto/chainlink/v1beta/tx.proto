syntax = "proto3";
package chainlink.v1beta;

import "gogoproto/gogo.proto";
import "google/api/annotations.proto";
import "chainlink/v1beta/genesis.proto";

option go_package = "github.com/ChainSafe/chainlink-cosmos/x/chainlink/types";

// Msg defines the Msg gPRC service.
service Msg {
  rpc SubmitFeedDataTx(MsgFeedData) returns (MsgResponse) {
    option (google.api.http).put = "/chainlink/feed/data";
  }
  rpc AddModuleOwnerTx(MsgModuleOwner) returns (MsgResponse);
  rpc ModuleOwnershipTransferTx(MsgModuleOwnershipTransfer) returns (MsgResponse);
  rpc AddFeedTx(MsgFeed) returns (MsgResponse);
}

// MsgModuleOwnershipTransfer is the type defined for module ownership transfer
message MsgModuleOwnershipTransfer {
  // current module owner address
  bytes assignerAddress = 1 [(gogoproto.casttype) = "github.com/cosmos/cosmos-sdk/types.AccAddress"];
  bytes newModuleOwnerAddress = 2 [(gogoproto.casttype) = "github.com/cosmos/cosmos-sdk/types.AccAddress"];
  bytes newModuleOwnerPubKey = 3 [(gogoproto.moretags) = "yaml:\"pub_key\""];
}

// MsgFeed is the type defined for new feed
message MsgFeed {
  // FeedId is the unique identifier of the feed
  string feedId = 1;
  // FeedOwner is the owner of the feed
  bytes feedOwner = 2 [(gogoproto.casttype) = "github.com/cosmos/cosmos-sdk/types.AccAddress"];
  // DataProviders is the init list of data provider of the feed
  repeated DataProvider dataProviders = 3;
  // The number of signatures required for a feedData submission to be valid
  uint32 submissionCount = 4;
  // The interval between which a new round should automatically be triggered.
  // The given value in milliseconds will only be approximate within block intervals
  uint32 heartbeatTrigger = 5;
  // The fraction of deviation in the feed data required to trigger a new round.
  // For example if the price of ATOM/USD changes by 1% then a new round should occur
  // even if the heartbeat interval has not elapsed.
  uint32 deviationThresholdTrigger = 6;
  // Module owner who signs the add feed tx
  bytes moduleOwnerAddress = 7 [(gogoproto.casttype) = "github.com/cosmos/cosmos-sdk/types.AccAddress"];
  // TODO: RewardConfig: Struct describing how rewards should be paid
}

// DataProvider is the type defined for feed data provider
message DataProvider {
  bytes address = 1 [(gogoproto.casttype) = "github.com/cosmos/cosmos-sdk/types.AccAddress"];
  bytes pubKey = 2;
}

// MsgFeedData is the type defined for the data of the feed
// It could be an OCR report feed, or any general feed data in the future
message MsgFeedData {
  // FeedId is the unique identifier of the feed
  string feedId = 1;
  // Submitter is the leader of the current round who is calling the module to submit feed data
  bytes submitter = 2 [(gogoproto.casttype) = "github.com/cosmos/cosmos-sdk/types.AccAddress"];
  // FeedData is the report for price feed, could be used for general feed data
  // From proposal: The reports generated by Chainlink nodes off-chain using the OCR protocol are ABI encoded byte arrays
  // which means each report is a byte array which could be deserialized to OCRAbiEncoded type
  bytes feedData = 3;
  // Signatures is the data provider signature list of the current round
  repeated bytes signatures = 4;
}

message MsgResponse {
  uint64 height = 1;
  string txHash = 2;
}

// this will be the implementation used later will use pseudo OCR ABI encoded data instead
// because the structure of how the OCR will be generalized is still unknown
// OCRAbiEncoded implments the OCR data that is ABCI encoded. The use and form will conform to the 
// Chainlink protocol specification.
message OCRAbiEncoded {
  // Context should be a 32-byte array struct.
  bytes Context = 1;
  // Oracles should be a 32-byte record of all participating oracles. Assuming this is data provider address?
  bytes Oracles = 2;
  // Observations should be an array on int192 containing the providers' independent observations.
  repeated Observation Observations = 3;
}

message Observation {
  bytes data = 1;
}

// OCRFeedDataInStore defines the type for OCR report that persists into the store
message OCRFeedDataInStore {
  MsgFeedData feedData = 1;
  OCRAbiEncoded deserializedOCRReport = 2;
  uint64 RoundId = 3;
}